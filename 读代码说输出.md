 补充知识 

 浏览器内核 

常用浏览器内核:

webkit、gecko、presto、trident

 常用输出方式 

1.console.log/dir/table



2.浏览器窗口弹窗:alert/confirm/prompt

三种方式输出的结果都必须经过toString转换为字符串

 变量 

多种定义方式:

var/let/const/function/import/class

创建变量的方式:

 var   

1.var声明作用域

函数作用域，在函数外部不能访问

以下几种方式都被允许:

var a=1

var a

a=1（不被推荐）

2.var声明存在变量提升

function foo(){

  console.log(age)

  var age=26

}

foo()

这里会输出undefined，是因为var会产生变量提升，先把var age提升到函数顶部

### 带var和不带var的区别

 ![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640860560568-6054e05e-13d9-49b6-a227-795036edcc73.webp) 

 let 

1.变量不能重复声明

2.块级作用域(if else while for 全局，函数，eval)

3.不存在变量提升

4.不影响作用域链的正常作用

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640516475346-f9b4920c-3b5d-4956-80f2-92fe50fa1c6c.webp)



 const 

1.一定要赋初始值

2.一般常量使用大写(潜规则)

3.常量的值不能修改

4.块级作用域

5.对于数组和对象的元素修改不算做对常量修改，不会报错

 变量提升 

重点1:不管条件是否成立都要进行变量提升

重点2:自执行函数不进行变量提升

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640862759318-045b8674-5273-4938-945e-f682cf28623f.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640859744037-ded85455-5dba-4b77-a7a4-5aa288581fa3.webp)



 let/const/var 的区别 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640860518956-b558e3ec-7290-4222-bcad-333b18b0a3d8.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640860813181-edd3dbc5-baa8-4ef6-8e9d-dff46e9789e2.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640863191293-16c39456-f126-4a89-8933-55f8da312940.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640922550642-00775351-4698-4108-b8d8-b82831fead6f.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640922587596-1440110e-4fea-448c-8aef-3d681daf4b8c.webp)



暂时性死区(let/const具有词法解析的功能，所以可以解决暂时性死区的作用)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640863310336-5d5fc395-48d0-4d15-9c76-ae2de1991214.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640863351197-6b0f357e-eb6e-480e-ad19-b91d09014902.webp)



 词法解析词法检测 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640860902813-99dcecf0-77ee-4059-8728-8f84dc4db62c.webp)



 面试题 

### 1.求输出

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640861389765-46d8f03c-5606-4dc9-963e-85518d959f42.webp)



解析:555 333

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640861430739-7fd45d59-ca97-4962-910b-bcc0d2c94129.webp)





### 2.变量提升

题目1(重点)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640862057343-c4a03f79-c1c4-4d9d-b8d6-0707bd7e8929.webp)



解析:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640862087960-5238d4f2-0be9-4b4a-aaec-4d092c20a76b.webp)



题目2(难点)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640862132252-52434180-e1d0-4f57-b26a-e82c5b1d7dd7.webp)



### 3.自执行函数变量提升

报错

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640862913923-03140a5b-dc8d-4a8f-a52c-bd6da100039d.webp)



### 4.私有作用域下的变量提升

题目1

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640863798151-407f7d8f-8638-402e-9a66-f5061aa25bd8.webp)



解析:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640865503966-4634cd56-f252-4e7b-9675-cd4a9599368c.webp)



题目2

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640865965041-e3704f11-cd01-4ef0-83f0-163cb9deb951.webp)



解析：

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640865935314-e1afc0d6-dda8-47ab-8853-c2f7bcbf04f9.webp)



题目3

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640866798049-7bbb4e88-8332-41b3-8d5a-c4d3b689fd5c.webp)



解析:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640866780181-a91009b2-fea0-4689-8897-9fe2e04067a4.webp)



题目四

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640867487402-d52d0cbf-4b0c-41f5-b376-68764a8c6111.webp)



解析:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640867510968-6785defd-d463-4494-ad9b-664da392d89c.webp)



### 5、复习

习题1,2,3对比

选B

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923821524-b8e3f7a7-2d08-436c-9122-3eb399c1e8b7.webp)



解析:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923843593-498b1be7-7ab8-422d-b2a3-14c5f95516e3.webp)





### 习题2,选A

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923932476-a000c603-792d-49ab-9113-00d827411743.webp)



解析:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923948322-e7c13a50-2af9-441b-99ab-939dd4da7bcc.webp)



### 习题3

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640924068555-910fed76-8bcd-4e3e-8123-5c25c2fba00d.webp)



解析:选D

引用错误，a is not defined



### 习题4

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641295170211-361469a1-cac0-4ab9-925c-ae4f563f5a0a.webp)



选B

### 习题5

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641295985484-51d71a99-40e4-4168-be10-50bb1a3bee4f.webp)



答案选D



### 习题6

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641296037881-9ee3def3-2889-435d-8c41-794691510496.webp)



 数据类型 

 基本数据类型: 

 数字类型number 

包含:常规数字和NaN

### not a number

不是一个数，但它属于数字类型

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640518560998-5724b2e8-cf71-4570-b10c-a93bb0b061a7.webp)



这两种情况都会输出NaN

(用0当被除数在ECMAscript会输出NaN)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640518637849-17c97691-53fb-4630-bd65-0f50ec129bd5.webp)



NaN和任何东西都不相等，所以不能用它来判断类型

### 面试题:

1、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640606944290-c71833ba-8881-430a-92ce-d8ef461c86c5.webp)



由于NaN和谁都不相等

2、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640607458467-a6b7e697-d853-4a9e-85e2-ead14c03111c.webp)



答案选A

3、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640608389297-661302ec-d965-4174-b74c-263c49d1bd00.webp)



4、求下列6题的输出结果

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640659304772-0b7398e2-72ee-49e7-a614-11a94968dc6d.webp)



1  true

2  "2undefined"

3  "2boolean"

4  "2.6number"

5   false

6   122

5、求下列输出结果

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640659919842-df3d1185-2ab8-43c5-ba94-15aa61004196.webp)



1  false

2  0

3  string12false

4  NaN

5  "booleantrue"

### isNaN

检测一个值是否为非有效数字，如果不是有效数字则返回true，反之是有效数字返回false

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640519057090-e49ef583-2f0a-4753-b4d1-4d667c4e7502.webp)



注意点:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640519128890-e2f34437-62c2-4060-9b2c-42531ea6bb5c.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640519231943-82df219a-58da-4b55-a58f-07729f1c8850.webp)



isNaN的检测机制，在使用它时首先会验证检测的值是否是数字类型，如果不是，先基于Number()这个方法，把值转换为数字，然后在检测。

由于true可以转换为1，false可以转换为0，‘10’可以转换为10

### 其他类型转换成数字的方法

Number

将字符串转换成数字

只要字符串里是有效数字或空都能转换成数字

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640519484269-0e2f8115-cf9e-4b74-a9aa-cbd9a4de4f1d.webp)



将boolean转换成数字

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640519558066-a70692ae-65d7-4c42-ab1d-881a07c2803c.webp)



将null变为0，undefined变为NaN

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640519730623-bed42219-3cde-470a-861a-01aa647f02f3.webp)



把引用数据类型转换成数字是先基于toString方法将他转换成字符串，然后在转换为数字

对象toSring后是[Object object]====》NaN

数组toSring后[].toString===>""===>0

[12].toString===>"12"===>12

[12,23].toString===>"12,23"===>NaN

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640519888802-c0143108-8019-48fb-8d1b-3a4915ce35fd.webp)



parseInt/parseFloat

这也是转换为数字的方法，对于字符串来说，它是从左到右依次查找有效数字字符，直到遇到非有效数字字符，停止查找(不管后面是否还有数字，都不在找了)，把找到的当做数字返回

parseInt/parseFloat([val],[进制])

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640520901843-91d3ccc3-4bd7-4ede-837f-47597ea49be0.webp)



还可以通过==来进行转换	

 字符串string 

 js里所有用单引号和双引号或反引号标起来都是字符串

### 把其他值转换成字符串的方法

[val].toString()

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640521811316-938436a9-bf4f-4b64-914e-2b02fbd65e9a.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640521871013-61471687-2655-4e73-a986-53421d772974.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640522002728-896c1829-d318-4491-8ca2-f8b28e6ef1a6.webp)



null和undefined是禁止toString的，但是他们转换成字符串的结果是"null","undefined"

特殊情况:



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640522057056-8fc2f293-1e20-4345-94bf-2ac0eea4fa66.webp)



字符串拼接

(一旦遇到字符串就不是数学运算而是字符串拼接)

只有加法才会产生字符串的拼接其他都叫数学运算

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640522357577-4ee5feb6-8420-4161-862c-a18f16ffdbb2.webp)





![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640522948884-0a5395fb-5957-4ebe-ba08-62194f7c339f.webp)



### 重点i++和++i

一、

let i='10'

i=i+1=>'10'+1=>'101'

i+=1=>'101'

i++=>i=11

所以i++和以上两种完全不一样，他是纯粹的数学运算

二、i++和++i都是数学运算中的累计1，区别是计算顺序



let i=1

5+(i++)

答案:6(先5+1然后在i++)

i=1

5+(++i)

答案:7(先i+1,然后再5+1)









 布尔值boolean 

只有两个值true/false

### 其他类型转换为布尔类型

只有0、NaN、‘’、null、undefined五个值转换成false

//!：取反(先转为布尔，然后取反)

//!! :取反再取反，只相当于转换为布尔===》Boolean

其他值都转换成true(没有特殊情况)

 空对象指针null 

### null与undefined

null和undefined都表示没有，

null:意料之中(一般都是开始不知道值，收到先设置为null，后期赋值操作)

undefined:意料之外(不是我们能决定的东西 )

 未定义undefined 

 唯一值symbol 



 数组Array常用方法 

特殊的对象，数字作为索引，length代表长度



方法的作用和含义

方法的实参(类型和含义)

方法的返回值

原来的数组是否会发生改变

 数组增删改的方法(会改变原数组) 

 这一部分方法会修改原有的数组

向数组末尾增加内容

### push方法

@parmas 多个任意类型

@return 新增后数组的长度

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640669482684-fbaa2be3-d939-436b-81ba-16ca10983be7.webp)



### 直接用数组[索引]

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640669570360-bb8f3ac2-b113-4ee0-a24f-083e3d57a1a2.webp)



### 扩展运算符

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640670317475-ad62196b-eb28-4d00-8a3d-5b0df8527b58.webp)





向数组开头添加内容

### unshift方法

@parmas 多个任意类型

@return 新增后数组的长度

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640670110544-f94cc674-0a10-42c4-8553-104e43a8babc.webp)



### 扩展运算符

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640670271721-26abbccb-eaad-420b-bfe6-861112567b04.webp)



  

### 删除数组中的第一项

#### shift方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640670526287-e78e0c60-88d3-4f06-a0b2-cb7efb125744.webp)



#### delete方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640670671056-dbc842bd-df1a-40fd-a8d1-2115c3e5fae4.webp)



但是数组的长度不会变，所以项目中不会用

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640670693911-f1970351-253a-4d10-8a9b-87e3820d8232.webp)





### 删除数组中的最后一项

#### pop方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640670794914-5c22208a-784c-41ba-9875-80a15f4672e8.webp)



#### delete同上

没啥用

#### 通过修改length(牛逼)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640670895488-c71f190f-f7d1-4bf2-8960-71b7f7813e99.webp)



### 通过splice方法

ary.splice(ary.length-1)





### splice:实现数组的增加、删除、修改

实现删除:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640683179651-02e29d47-6dde-463b-b184-1426f1421b85.webp)



实现增加/修改:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640685359380-d2249bf7-ffee-451f-9a70-641d405a4e8d.webp)





 数组查询和拼接的方法(不会改变原数组) 

### slice方法

数组查询

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640689948752-afa8f545-c03e-40b5-8926-fd786ab322c8.webp)



### concat方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640690208051-fd55481c-5ef5-4b80-be4e-0d58948a60f7.webp)







 数组转换为字符串的方法(不会改变原数组) 

### toString方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640690434699-9eef4854-f8ac-4604-914a-327cc35e0d4a.webp)



### Join方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640690627205-b2d6c85e-8ad5-48b2-b51d-75db4e3af006.webp)



 检测数组中包含某项(不会改变原数组) 

### indexOf和lastIndexOf

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640691224803-e9f2996d-06ca-4bba-a9dd-b01b4a8bd778.webp)



### includes

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640691287548-edbd6312-ab9f-4689-9db4-6d10c99e53ff.webp)





 数组的排序或排列 

### reverse数组反转

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640691695298-a84356ed-c209-4c27-a75c-2ccbb4f65cf0.webp)



### sort数组排序

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640692149488-7d997fbe-f221-4fc7-af1b-c8a3b5af01f5.webp)





 遍历数组的方法 

### forEach方法(原理数组不变)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640692553890-85c04546-91fe-475b-838a-b1429fffa19e.webp)



 数组去重的方法 

### 循环原有数组中每一项

1.for循环方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640692754423-ae865c11-b0b7-48c7-81ad-992ca381319b.webp)



2.forEach优化版

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640693001142-7c3037a7-5a65-4aca-8c27-217c76e7e3d2.webp)



3.set版本

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640693231644-96be15f5-071b-4ebc-a9e6-ac4c77f98f18.webp)



4通过对象数组去重

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640744177880-b7baceec-777e-44ca-8d3b-46c393414b0d.webp)



 字符串String常用方法 

所有单引号、双引号、反引号包起来的都是字符串

### 字符串基本操作

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640745537276-ae97eb77-40c0-4d76-8c77-899585254f64.webp)



 根据索引获取某个值 

### charAt和charCodeAt

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640746014035-ec33ddcd-d0af-433f-9715-d70e35121dd0.webp)



 字符串截取 

### substr、substring和slice

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640746709233-0aa7a42e-7abf-432d-ae3a-6b4450edf009.webp)



 字符串查找 

### indexOf/lastIndexOf

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640747098949-cee88db3-a4f5-49ae-81fe-795c5a64120e.webp)



 字符串字母大小写转换 

### toUpperCase()和toLowerCase()

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640747436749-65df6097-316a-4309-aba7-aacf58839675.webp)



 字符串转数组 

### split

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640747700781-3d7144c3-e65f-4db3-84d4-739ac50252a0.webp)



 字符串替换 

### replace(老字符，新字符)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640747975971-5a3e8a73-7050-40ab-9726-0663afefc57c.webp)



  对象数据类型object 

### 对象类型

   普通对象 {}

   数组对象 []

   正则对象 /^[+-]?$/

   Mah数学函数对象

   日期对象

函数数据类型function

 Math对象 

数学函数:但是它不是函数，它是一个对象，对象中存储了很多操作数字的属性方法，因此被称为数学函数

1.math.abs([value]):获取绝对值，永远是正数或0

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640666995742-ee34fda2-5752-486b-bfb1-8be0f7c0b306.webp)



2.ceil和floor([number value])

把一个数向上取整和向下取整

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640667298076-eb5014ca-bb5c-45a2-a61f-9ce42542e0b5.webp)

69



3.Math.round()四舍五入

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640667454273-112cfd32-8afc-4113-8db0-ce9b2ec7f53f.webp)



四舍五入负数0.5是舍弃，正数0.5是加入

4.Math.max/min（）获取最大值最小值

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640667696813-66d8d0a1-38c6-4847-a231-f35df60fb083.webp)



传的必须是数字，如果要传数组可以用...运算符

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640667738441-fc5110f2-e213-4522-aee5-6f884ea92194.webp)



5.Math.sqrt()/pow()

sqrt:给一个数开平方(负数不能开平方)

pow:计算一个数的多少次幂函

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640667935887-eab5cbdb-6da3-479c-b3de-978c7c414a1f.webp)

 



6.Math.random()随机数

扩展:获取[n,m]之间的随机整数

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640668490203-52acb987-1a54-4be3-9141-7cc112a7e9bf.webp)



例如:获取[25,96]之间的随机整数





 Date日期对象 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640775199877-e1ff0e51-fadc-4204-bd7c-dc1eb6fd302b.webp)



### 获取属性名对应的属性值:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640526694861-fb9fd9d9-9242-4c26-83f6-1c4072834780.webp)



newDate除了获取当前时间，还可以把一个时间格式字符串转换为标准的时间格式

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640777561288-d493bc91-e7a9-4c51-994c-bc96f6c5ab7a.webp)







### 堆与栈存储机制

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640526725342-0d8cce07-ffa1-44b4-bc29-2526064f9c88.webp)



面试题1:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640526639717-c53bcc8f-3374-43bf-a206-b42553440ffb.webp)





解析:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640526672412-1291642f-7ff2-419b-b9e1-b21cd5d6c938.webp)







面试题2:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640538102909-cdcfb508-ca5f-4742-b0ae-f0d4bf88224c.webp)



面试题3

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640656546200-75509517-4082-453b-a38b-226fc26cf53f.webp)



 数据类型检测 

 typeof(val): 

(用来检测数据类型的运算符)

检测number、string、boolean、undefined都是其本身

检测function返回function

检测null和object(数组对象，普通对象，正则对象)返回object

局限性:

1、typeof null输出object，null不是对象，是一个历史遗留问题

2、基于typeof无法细分出是普通对象还是数组对象，因为返回结果都是"object"



### 面试题

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640538588394-c374717c-c820-4ef4-9a4f-1de56135d54b.webp)



解法: typeof []===>"object"

typeof "object"===>"string"

所以只要出现两个及两个以上同时出现typeof结果就是string



 instanceof 

(用来检测当前实例是否属于某个类)

检查某个实例是否属于这个类

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641298022083-13ba8200-c850-40be-8630-f5426b530d8d.webp)



局限性:要求检测的对象都要是对象类型,基本类型实例无法用它检测出来

基本类型为什么不能检测:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641298388846-b754623d-346f-457b-83f0-04c7bf6a4b3f.webp)



让基本类型也能检测的方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641298325888-6eadee3f-f635-42ae-b704-c91c997fafc0.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1642039383462-d5914c62-97de-4b3d-bf8e-81255c0b28c2.webp)



上面这题啥都不会输出，因为new创建出来的是一个对象

!a是false所以不会输出东西

 constructor 

基于构造函数检测数据类型(基于类)







 object.prototype.toString.call(): 

检测数据类型最好的方法





 循环 

### for循环

注意:

1.遇到continue结束本次循环

2.遇到break结束所有循环

### for in循环

用来遍历循环对象中的键值对(continue和break同样适用)

### 面试题

1、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640656585476-cf60b207-7ee6-4937-92ea-777563f48f0a.webp)



输出:0  0

2、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640656614782-51e9d790-f39f-4312-97b3-3bbdc0eff030.webp)



输出:10

3、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640656644339-cc456ce6-e92f-42f2-ae7a-ddd6e4bb8685.webp)



输出:5

4、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640656733085-56f0697f-daf4-4ee2-8ffa-ca3a2b1632be.webp)



答案:死循环

5、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640657132935-919e4b93-2f88-4c61-aedd-b8db41e268e1.webp)



输出:

11  9



 ==和===的区别 

==:相等，数据类型不同，先转换为一样的再比较

===:绝对相等，必须类型和值都相同才为true(switch中的，每一种case值的比较都是基于===来完成的)

 函数 

函数是一个方法或一个功能体，函数就是把实现某个功能的代码放到一起进行分装，以后想要操作这个功能把函数执行就可以



提高代码重复使用率(低耦合高内聚)

### 创建函数

function [函数名](形参1，形参2){

​    函数体

​    return  [处理后的结果]

}



[函数名]()



创建函数时设置了形参变量，但执行的时候没有传递对应的实参，那么形参变量默认的值是undefined，

函数体内部创建的变量是无法获取和操作的，如果想要获取内部的信息，我们需要基于return返回机制，把信息返回才可以

函数体重遇到return，后面代码就不会再执行了



 #### 返回值

1、返回一个值，拿变量接收

2、想用函数内部变量需要有返回值

3、return的作用可能只是不想让后面代码继续执行

4、没返回值默认返回undefined



### 匿名函数

把一个匿名函数本身作为值赋值给其他东西，这种函数一般不是手动触发执行的，而且靠其他程序驱动触发执行(例如:触发某个时间的时候把他执行)



### 函数底层运行机制

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640663695472-1d7df685-2003-4c9e-9084-e2c8b69b0dcf.webp)





### arguments函数的实参集合

1、类数组集合，集合中存储这所有函数执行时，传递的实参信息





### 箭头函数

 this 

函数执行的主体(不是上下文):意思就是谁把函数执行的，那么执行主体就是谁

1、给元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素本身

2、自执行函数的this是window或undefined

3、如何确定执行主体(this)是谁，当方法执行的时候，我们看方法前面是否有点，没有点this是window或undefined，有点前面是谁就是谁

this判断

1、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923289552-d60e92f4-b83f-4569-99b9-f67bed59f4ef.webp)



2、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923300285-91f778ed-cc28-4d94-a4fd-9874123d0eb7.webp)



3、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640923482547-429d2d26-a17a-4ba5-8c52-bbe3c5314b22.webp)



 闭包作用域 

### 创建函数 

   开辟一个堆内存

   把函数体的代码当做字符串存储进去

   把堆内存的地址赋值给函数名/变量名

   函数在哪创建，那么它执行时候所需查找的上级作用域就是谁

#### 函数执行

   形成一个全选的私有作用域、执行上下文、私有栈内存(执行一次形成一个，多个之间不会产生影响)

#### 形参赋值&变量提升

   代码执行(把所属堆内存中的代码字符串拿出来一行行执行)

   遇到一个变量首先看他是否是私有变量(形参和在私有作用域中声明的变量是私有变量)，是私有的就操作自己的变量即可，不是私有的则向上级作用域中查找...一直找到全局作用域为止=>作用域链查找机制

   私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来，这种机制其实就是闭包的保护机制

### 关于堆栈内存释放问题(以谷歌浏览器为主)

函数执行就会形成栈内存(从内存中分配的一块空间),如果内存都不销毁释放，就很容易会导致栈内存溢出(内存爆满，电脑就卡死了)，堆栈内存的释放问题就是学习js的核心知识

### 堆内存释放问题

//=>创建一个引用类型值就会产生一个堆内存

如果当前创建的堆内存不被其他东西所占用，浏览器会在空闲的时候查找每一个内存的引用状况，不被占用的都会自己回收掉

### 栈内存释放

//=>打开浏览器形成的全局作用域

//=>手动执行函数形成的私有作用域

//=>基于ES6的let/const形成的块作用域是栈内存



1、一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉(排出出现无限递归，出现死循环的模式)

2、一旦栈内存中的某个东西(一般都是堆地址)被私有作用域以外的事物给占用了,则当前私有栈内存不能立即被释放销毁



闭包:函数执行形成不能被释放的私有栈内存，这样的才是闭包



 闭包的作用: 

1、保护(私有变量和外界没有必然联系)

2、保存(形成不销毁的栈内存，里面私有信息被保存下来了)

3、防止全局变量污染问题(jq)

jq里面有很多方法，如果这时候一个程序员声明了一个方法比如prevAll，和jq里提供的方法重名了，这时候会存在覆盖吗？

答案是不会，因为为了防止全局变量污染(解释:导入JQ后,里面有大量的方法，如果这些方法不保护起来很容易和用户编写的方法产生冲突，这就是全局变量污染，为了防止这种污染，jq中的方法需要用闭包保存起来)

4、从性能角度讲，真实项目中应该减少对闭包的使用(因为闭包会产生不释放的栈内存，过多使用容易导致内存溢出或者性能降低)

jq中闭包用处

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640921292249-54b5132b-e059-48f5-8d75-04f5036521c3.webp)



### 真实项目中

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640921273247-3c7ce39e-9996-4915-b250-582c814000c7.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640921239898-2fc8c5c0-d49b-45d4-8db9-773c9c8cd2d3.webp)



 函数的三种角色 

 练习题 

### 一、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640919507306-3af7abc8-976e-4bc5-a1da-dde44683f336.webp)



解析：

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640919526377-10d08c15-19a6-4abc-818b-29cf128926cc.webp)



### 二、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640920078932-ed07d277-4f3c-4540-b484-041a7a15f0ae.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640920060506-006782c9-837c-4444-bac7-34bd1f152942.webp)



### 三、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641295723812-aaf27bf2-6102-4b05-8a45-1b788fb232a4.webp)



答案:11 12 0

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641295804196-13111ecf-851a-47d4-81dc-acd61ae53219.webp)



### 四、很难的闭包

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641455833721-6d541a4f-261a-459e-a030-77a052cb6e5f.webp)





 实现一些常用需求 

 时间字符串处理 

需求:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640754615214-6bb87ae2-3c86-4faf-ae7e-a97897e87d56.webp)



实现方法:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640754635029-0e1237c7-0f09-4cad-9147-e4a81e246406.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640754644084-925acdf6-4288-4449-a284-87407418ecd3.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640754650348-39ee4faf-c6c4-4f84-943d-b1f5a7bd6995.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640754658941-68d9b3d3-eda0-4aac-952e-5799e0b727cd.webp)



方法二:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640778203897-790408e9-42cf-4f08-aeb3-f5ae8d65992c.webp)



 queryURLParameter获取URL地址问号后面传递的参数信息 

简化版

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640755561249-bc29e6ca-58e7-435c-9861-3330b09e12b1.webp)



普通版封装

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640756730991-cf552b39-33d0-4969-b934-32b8cd7926f2.webp)



基于正则封装

 实现4位验证码 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640774206200-33e0eb48-0a7d-4a89-81fc-c943803c7d71.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640774220986-f71c97da-5ba7-4135-a301-33bc3a7c9bb0.webp)



 获取当前日期的具体显示 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640777196070-6f185e3f-3d03-466a-990d-24af0a47d379.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640777235611-a987178c-eac2-4b9c-86b0-6e9fa2d3b14c.webp)







 DOM 

 获取dom的方式的9种方法 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640778706581-ed9a2fd1-2ca1-4ab8-a8b9-5c2915af130a.webp)



 JS中的节点和描述节点之间的属性 

节点:Node

节点集合:NodeList(getElementsByName/querySelectorAll获取的都是节点集合)

节点分类:

元素节点、文本节点、注释节点、文档节点document

.......

### 描述节点之间关系的属性

childNodes:获取所有的子节点

children:获取所有的元素子节点(子元素标签集合)

firstChild:获取第一个子节点

lastChild:获取最后一个子节点

firstElementChild/lastElementChild:获取第一个和最后一个元素子节点(不兼容ie6，7，8)

previousSibling:获取上一个哥哥节点

nextSibling:获取下一个弟弟节点

previousElementSibling/nextElementSibling:获取哥哥和弟弟元素节点(不兼容IE6，7，8)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640831979688-97c97b75-15b1-47e9-abdc-f38fc693f876.webp)



由于IE6,7,8会把注释当作元素节点所以自己封装

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640832005691-f6db58f4-9c2c-49e6-8924-c396960888af.webp)



 JS中动态增删改元素 

createElement创建元素对象

createTextNode:创建文本对象

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640832800769-7f88d3d6-eff8-4433-97bc-c5fccfae9f12.webp)



appendChild:把元素添加到容器的末尾

insertBefore:把元素添加到指定容器中指定元素的前面

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640832812363-44067670-6cc3-4fe6-8711-2fac7c0d6177.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640832954614-f502f6be-3b49-4a8d-a78f-065d8c7a3f8c.webp)



cloneNode:克隆，参数true为深克隆，参数false为浅克隆

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640833310681-1d25ab56-909d-4338-9de2-04dfc2b496b6.webp)



removeChild:移除容器中的某个元素

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640833412919-63b293dd-88d3-45e0-8602-06f06c290dbc.webp)



setAttribute():设置自定义属性

getAttribute():获取某个属性

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640833885430-aa22fb54-3b42-470d-98d7-f5fac9358859.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1640834181513-ccfde948-a58e-4c8a-b7d2-fad07861629a.webp)



 盒子模型 

 client 

width/height：(可视区(内容宽度+左右padding))，内容溢出与否对其无影响，获取的结果无单位，获取的结果是整数，会自动四舍五入，也可以通过这获取整个页面的可视化高度和宽度（document.body.clientWidth）

top/left

 offset 

width/height(在client的基础上加上了border，等于盒子本身的宽高)

top/left

parent

 scroll 

width/height(在没有内容溢出的情况下获取的结果和client是一样的，在有内容溢出的情况下，约等于真实内容的宽高，上或者左padding)

top/left(scrolltop:竖向滚动条卷去的高度/横向滚动条卷去的宽度)

 面向对象 

 单例模式 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641296298103-2750a714-c3c9-458e-9ca6-4d7fff23ce61.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641296491758-6d1910b4-b586-483b-8913-f954e0db2efa.webp)



 工厂模式 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641296994284-11f7f166-c777-4e63-bc95-ab3334eedc60.webp)



 构造原型模式 

### (重点)：new的时候不管加不加小括号都是将函数执行了，创建了对应的实例，只不过不加小括号不能传参

### new了一个函数后会发生什么

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641299205748-1f67f464-ed5d-4dbb-8016-b41b0b9e9c44.webp)



### 实例是什么

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641297473750-fac38cf5-73b6-4d44-ac91-4f41db82a02c.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641297459663-65b262bf-00ca-4462-bb5e-b08426f996a2.webp)



### 构造函数return的问题

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641297723538-480a8989-7c72-44ba-909d-26c789b1aeec.webp)



 构造函数习题 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641298599341-e8fe0538-dc19-42cd-aab5-2181917823e7.webp)



解答:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641298948938-c332e6a8-19ac-49a9-9f8c-f5857337e790.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641298984867-d559ed83-99b2-4606-b27d-fe3c64e1ca0f.webp)



 检测对象属性 

 hasOwnProperty 

检测某一个属性名是否为当前对象的私有属性

“in”：检测这个属性是否属于某个对象(不管是私有属性还是公有属性，只要是它的属性。结构就位TRUE)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641379120649-506041c4-84c5-44a2-a453-bb1b56827c61.webp)



### 可以基于内置类原型自己写一个方法hasPubProperty

检测某个属性是否为对象的公有属性

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641379628958-705d0ae1-2568-42a3-9598-fdbaf0b267b0.webp)



 什么是公有什么是私有属性 

自己堆里面有的就是私有属性

需要基于__proto__查找的就是公有属性

(__proto__在IE浏览器中被保护起来了)

 es6创建类Class 

传统创建类的局限性: 由于传统的函数可以扮演三种角色，一种是对象的属性，一种是普通函数执行，一种是构造函数，所以针对性不强

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641468977521-2de9a3ab-905a-4879-b304-1ffe2f29130a.webp)



es6创建类: Class创建的类只能new执行不能当普通函数执行

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641469677502-d786fbd5-ea9c-44b8-8403-65ac070cf811.webp)



 面向对象的继承 

 原型继承 

子类原型指向父类的实例

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641994558926-4ce6bb4c-7f02-4137-8a8b-abc199fc381a.webp)



原型继承的原理

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641996836131-90796ef6-56e3-4872-b41c-4f5c3731bf0e.webp)



原型继承缺点:

1、子类可以修改父类原型上的方法

2、父类中私有或公有的属性方法，最后都会变成子类中公有的属性和方法



 call继承 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641995831157-a25b5b4e-56ff-4eaf-8190-a8a4055e115f.webp)



 寄生组合继承 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641996107694-671106c8-4328-4961-8774-f8adf743d31e.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641997817753-f85b36f8-f8ec-4c73-95f3-611e1fd6c70e.webp)



 ES6继承 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641998830852-cec68bfa-4751-4f5e-b442-b4bd8d75e950.webp)



 原型及原型链 



1、每一个函数数据类型的值，都有一个天生自带的属性:prototype,这个属性的属性值是一个对象（用来存储实例公用的属性和方法）

​       普通函数

​        类(自定义类和内置类)

2、在prototype这个对象中，有一个天生自带的属性:constructor，这个属性存储的是当前函数本身

3、实例身上有一个自带属性__proto__，这个属性指向所属类的原型prototype

​                      普通对象、数组、正则、math、类数组

​                      实例也是对象数据类型的值

​                      函数的原型prototype属性的值是对象类型的

​                      函数也是对象数据类型的值

原型链查找机制

  1、先找自己私有的属性，有则调取使用，没有继续找

  2、基于__proto__找所属类原型上的方法(Fn.prototype),如果还没有则基于__proto__往上找，一直找到Object.prototyoe为止



 this问题 

面向对象中私有/公有方法中this的遵循原则: 1、方法执行看前面是否有点，点前面是谁This就是谁

 2、把方法中的this进行替换

 3、再基于原型链查找的方法确定结果即可

一道题理解面向对象中this问题

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641380170260-24d56afa-ee88-45fa-b232-8a1d0f76e2ad.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641380181865-0400ae5e-68e6-4358-a4ad-5770431a8e68.webp)



基于内置类扩展方法: 1、如果我们写的方法把内置方法覆盖了，那么调用时候就会出现问题(比如我重写一个push方法把数组原型上的push方法给覆盖掉了，就很恶心)



需要注意: 1、自己扩展方法不能影响原有内置方法

链式写法：

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641381539698-8ffc083e-8021-49df-988f-5801159d3c91.webp)





 this问题及面向对象习题 

题一

已知左边代码求

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641383213896-78b36529-1d40-454a-83f9-42966674a1dc.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641383443402-3f078f66-a4b0-4ce0-80c3-b1098bb0e732.webp)



题二、重构类的原型问题

重构类的原型:让某个类的原型指向新的堆内存地址(冲定向指向)

问题1:重定向后的空间中不一定有constructor属性(只有默认给prototype开辟的堆内存中才存在constructor)，这样导致类和原型机制不完整，所以需要手动给新的原型空间设置constructor属性



问题2:原有属性和方法没啥用了(如果需要克隆到新的原型堆内存中，需要额外的处理)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641383555846-7e981a91-e141-4b7e-8d33-dc9be43b8616.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641384143537-ec59d08d-64ba-4d7b-ab35-36fc3db6e79d.webp)



题三、

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641384368017-96dcf18a-a928-4487-9d6c-da657a95d51a.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641384355225-67a5b172-1645-4d0d-b096-6d5aa8202ea0.webp)



题四

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641384587713-87985013-a316-4437-8343-d96b6dcb618f.webp)



题五（原型重定向最难题）

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641384804827-cc72cc6c-e346-4077-86e2-860119b4b3df.webp)



面向对象第五视频还没看

题六

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641385464451-6c1b9036-0925-429f-a3bb-dbb3a3fc3fa9.webp)



题7阿里面试题(超级难)

题目

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641454697725-707f347c-0dd6-4a13-99ac-82d91477f998.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641455320244-e4109862-ee53-406b-9128-ff80b8d2374b.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641455340407-9b685b53-432c-4b89-ac8b-873f1655ebc9.webp)







 call、bind和apply的区别 

共同点:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641456200854-86000c08-de28-4dcf-a18c-13095fde23a3.webp)



 Call方法 

执行过程:

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641456308354-f7dc5898-bdaf-4c9a-bc57-779693a71881.webp)



call的机制

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641457035489-1234ea5e-eba9-498e-b342-5604637f3e1f.webp)



想让fn执行时指向obj，那就给obj加个fn属性



call的执行规律

### 如果只有一个call让call左边的那串东西执行，

### 如果有两个或两个以上的call让括号里传的参数执行

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641465770553-38d680d0-bf36-4056-9393-0dac225e8d15.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641465787949-bbc1eec1-5477-44c8-b11d-fb600c5848c7.webp)



 apply方法 

apply与call的区别在于传递给函数参数的方式不同



call是一个个传承

apply是按照数组传参



 bind方法 

和call/apply一样，也是用来改变函数中的this关键字的，只不过基于bind改变this，当前方法并没有被执行，类似于预先知道this

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641466264268-eb93d988-626d-415a-bba9-4be4d1279f25.webp)



 call与apply的区别，哪个性能更好 

共同点:

都是Function原型上的方法，改变this指向

call是一个个传参

apply是按照数组传参

还有一个bind，bind是改变this指向，不执行

call的性能要比apply好一些，尤其是在传递函数参数超过3个的时候





深入使用与面向对象关联

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641470759717-98b37b22-7272-4a32-860a-46bb6b9d1486.webp)



由于类数组原型没有指向Array.prototype，所以







 Promise 

ES6语法规范中增加的内置类，用来处理js异步编程的，而所谓的promise设计模式，就是基于promise对异步操作进行管理



 Promise三个状态: 

●待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。

●已兑现（fulfilled）: 意味着操作成功完成。

●已拒绝（rejected）: 意味着操作失败。



new Promise([executor])

[[executor]简称EXE]

1、New Promise的时候会执行一个函数，创建一个Promise的一个实例

2、Promise把EXE执行，而且还给EXE传递了两个参数(这两个参数也是函数类型):

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641879490527-b965c0e5-d229-4b4c-aa76-73d8920ded38.webp)



====》resolve函数:它代表PROMISE处理的异步事情是成功的，把Promise状态改为fulfilled

====》reject函数:它代表PROMISE处理的异步事情是失败的，把Promise状态改为rejected

3、EXE函数中放的就是当前要处理的异步操作事情

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641879538427-e993eae4-7446-4b6f-81b2-4e26ab42bdf0.webp)





 Promise构造函数原型上的方法 

 then方法 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641880708296-a527457d-8637-44ea-869f-e8307cd31363.webp)



 catch方法 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641880813564-814ab13b-d934-4446-a03e-1117b12bf1ae.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641880849095-b3b2822c-7dc8-4326-a951-c13b508c5c8d.webp)



类似于js里的try、catch(错误捕获)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641881465821-f6817834-c41a-4b3f-9e29-4f7df991375a.webp)



 finally方法 

无论成功还是失败都会执行的方法(一般不用)

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641881043976-c8b63eeb-d35c-44ff-bf79-8cad2e50c7a9.webp)





执行then/catch/finally是一个全新的promise实例，所以可以链式写下去；下一个then中哪个方式会被执行，由上一个then中某个方法执行的结果来决定

上一个then中某个方法的返回值会传递给下一个then方法

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641892679548-d539c5d1-822f-43ff-84f7-374b3cca740c.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641893234217-d1027223-173a-4b00-91d2-375970770371.webp)





 PROMISE链式调用 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641894179539-3d83a208-859b-4b00-b5ca-691aafcb8201.webp)



输出2 3 AAA 5



 Promise类方法 

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641897871454-086d2180-f293-48d0-9d48-a7548925ccba.webp)



 all方法 

all要都执行完之后才会有结果

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641894413903-96359836-7f7f-49d4-836d-e2235b0e60eb.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641894383661-c34de00d-d548-47c9-b0c3-657a8ae8f147.webp)



 race方法 

哪个promise方法先处理完，以最先处理完为主

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641894717755-bc0d7d54-cb81-41e6-b424-ff71b03f4b33.webp)



![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641894697879-49c33487-be02-4aef-a499-d4cb07a42c8b.webp)







Promise的执行机制

![image.png](D:/%E6%96%87%E4%BB%B6/typora%E5%9B%BE%E7%89%87/1641897609788-6dd9cfae-5584-42bd-8d0b-10ec76649315.webp)





 前端模块化